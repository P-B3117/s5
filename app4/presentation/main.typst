#import "@preview/touying:0.6.1": *
#import themes.university: *
#import "@preview/cetz:0.3.2"
#import "@preview/numbly:0.1.0": numbly
#import "@preview/theorion:0.3.2": *
#import cosmos.clouds: *
#show: show-theorion

// cetz and fletcher bindings for touying
#let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true))

#show: university-theme.with(
  aspect-ratio: "16-9",
  // align: horizon,
  // config-common(handout: true),
  footer-a: [pouc1302 & stel2002],
  config-common(frozen-counters: (theorem-counter,)),  // freeze theorem counter for animation
  config-info(
    title: [Résolution de la problématique app4],
    subtitle: [Algèbre linéaire et filtres numériques],
    author: [Charles Poulin-Bergevin, pouc1302 \ Laurent Stephenne, stel2002],
    date: datetime(day: 24, month: 2, year: 2026),
    institution: [Université de Sherbrooke],
    // logo: image("logo.jpg", width: 20%),
  ),
)

#set heading(numbering: numbly("{1}.", default: "1.1"))

#title-slide()

== Table des matières <touying:hidden>

#components.adaptive-columns(outline(title: none, indent: 1em))

= Correction des aberrations

== Fonction de transfert inverse

On inverse simplement le nominateur et le dénominateur, car $X/X=1$.

$ H^(-1)(z) = (z (z+0.99)^2 (z-0.8)) / ((z-0.9e^(j pi/2)) (z-0.9e^(-j pi/2)) (z-0.95e^(j pi/8)) (z-0.95e^(-j pi/8))) $

== Stabilité du filtre

#slide(composer: (1fr, 1fr))[
  Le filtre est stable, car tous les pôles de la fonction de transfert sont plus petit que 0. ($0.9$ et $0.95$)
][
  #align(center)[
    #image("poles-zeros-aberrations.png")
  ]
]

== Effet du filtre

#align(center)[
  #image("goldhill_aberration_comparaison.png")
]

= Rotation

== Code Python

```python
def change_image_base(image, matrix):
    width, height = image.shape[:2]
    new_image = np.zeros((height, width))

    for y in range(height):
        for x in range(width):
            old_x = width - x - 1
            old_y = height - y - 1
            new = matrix @ np.array([old_x, old_y])
            new_x = int(round(new[0]))
            new_y = int(round(new[1]))
            new_image[new_y, new_x] = image[old_y, old_x]

    return new_image
```

== Matrice de rotation

$ P(theta) = mat(cos theta, -sin theta; sin theta, cos theta) $
$ P(pi/2) = mat(0, -1; 1, 0) $

== Combinaison linéaire

#slide(composer: (1fr, 1fr))[
  #align(center)[
    $mat(e_1, e_2) mat(cos theta, -sin theta; sin theta, cos theta) = mat(u_1, u_2)$


    $u_1 = cos(theta) * e_1 + sin(theta) * e_2$ \
    $u_2 = -sin(theta) * e_1 + cos(theta) * e_2$
  ]
][
  #align(center)[
    Pour la problematique:
  
    $theta = pi / 2$ \
    $u_1 = e_2$ \
    $u_2 = -e_1$
  ]
]



== Rotation

#align(center)[
  #image("goldhill_rotate_comparaison.png")
]


= Débruitage

== Transformation bilinéaire

#let FE = 1600
#let FE2 = 2 * FE
#let fc = 500
#let wd = 2 * calc.pi * fc / FE
#let wa = 2 * FE * calc.tan(wd / 2)
#let wa_cute = calc.round(wa, digits: 0)

#slide(composer: (0.7fr, 1fr))[
  #v(1fr)
  $w_d = 2 * pi * f_c / f_e$ \
  $w_a = 2 * f_e * tan(w_d / 2)$ \
  $w_a = #wa_cute$ \
  $s = 2 * f_e * frac(1 - z, 1 + z)$ \
  $s = FE2 * frac(1 - z, 1 + z)$
  #v(1fr)
][
  #align(center)[
    #v(1fr)
    $H(s) = 1 / ((s / w_a)^2 + sqrt(2) * s / w_a + 1)$
    #v(0.5fr)
    $H(s) = 1 / ((s / #wa_cute)^2 + sqrt(2) * s / #wa_cute + 1)$
    #v(0.5fr)
    $H(z) = H(s) * frac((1 + z)^2, (1 + z)^2)$
    #v(0.5fr)
    $H(z) = frac(z² + 2z + 1, 2.3915 * z² + 1.107 * z + 0.5015)$
    #v(0.5fr)
    $H(z) = frac(0.42 * z² + 0.847 * z + 0.42, 1 * z² + 0.46 * z + 0.21)$
    #v(0.5fr)
  ]
    $"Num" = "[0.42 0.847 0.42]"$ \
    $"Den" = "[1 0.46 0.21]"$
    #v(1fr)
]

#slide[
  #align(center)[
    #image("pas_bruit_main.png")
  ]
]

== Comparaison

#slide(composer: (1fr, 1fr))[
  #align(center)[
    #image("poles-zeros-main.png")
  ]
][
  #align(center)[
    #image("poles-zeros-ellip.png")
  ]
]

#slide(composer: (1fr, 1fr))[
  #align(center)[
    #image("module-freq-main.png")
  ]
][
  #align(center)[
    #image("module-freq-ellip.png")
  ]
]

== Fonctions Python

#slide(composer: (1fr, 1fr))[
  Type du filtre: Elliptique \
  Ordre: 3
][
  #image("pas_bruit_ellip.png")
]

= Compression de l'image

== Équations de la matrice A

#slide(composer: (0.7fr, 1fr))[
 #v(1fr)
 $A = mat(4 ,1; 2, 5)$ \
 #v(5pt)
 $I = mat(1 ,0; 0, 1)$ \
 #v(5pt)
 $Delta = b² - 4 * a * c$ \
 #v(5pt)
 $lambda_"1,2" = frac(-b ± sqrt(Delta), 2 * a)$ \
 #v(1fr)
][
  #v(1fr)
  $"det"(A - lambda * I) = (4 - lambda) * (5 - lambda) - 2$ \
  $lambda_"1" = 6$ \
  $lambda_"2" = 3$ \
  #v(10pt)
  $(A - lambda * I)^(-1) * v = 0$ \
  $v_1 = mat(-1, 1)$ \
  $v_2 = mat(2, 1)$ \
  #v(1fr)
]

== Code python

```python
# covariance
covariant_img = np.cov(img, rowvar=False)

# valeurs et vecteurs propres
eigenvalues_img, eigenvectors_img = np.linalg.eigh(covariant_img)

# matrice de passage
sorted_idx = np.argsort(eigenvalues_img)[::-1]
eigenvalues_img = eigenvalues_img[sorted_idx]
eigenvectors_img = eigenvectors_img[:, sorted_idx]
P = eigenvectors_img.T

transformed_img = np.dot(img, P.T)
```

== Images compressées

#slide(composer: (1fr, 1fr))[
  50%
  #align(center)[
    #image("compressed.png", height: 80%)
  ]
][
  70%
  #align(center)[
    #image("compressed70.png", height: 80%)
  ]
]
